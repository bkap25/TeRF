The goal of this library is to provide a way to describe and compute with Term Rewriting Systems (TRS).
* DONE provide an initial implementation of TRSs
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-12 Wed 10:53]
- Note taken on [2017-04-10 Mon 09:19] \\
  I took a bit more time to look at [[https://github.com/mathics/Mathics/][Mathics]] this morning. It is an attempt to implement the [[http://www.wolfram.com/language/][Wolfram Language]] in Python. At the core of it is an already established syntax for writing TRSs. It's got significantly more developmental momentum than anything I might try to build for now. The two questions I need to answer, though, are what work would I need to do if I adopted Mathics, and what would I need to do if I built everything myself?
  
  If I adopt Mathics:
  1. I need to figure out how to strip its power down. That is, I don't think I would initially want the full power of strings and numbers. I would just want the symbols. This would probably be pretty tricky, as the language is built around the availability of both strings and numbers.
  2. I need to figure out how to represent Mathics statements as a TRS, as a collection of rules and symbols. This is probably being done somewhere in the system as the environment is formed and updated, but I'd need to find a way to get access to that environment.
  3. I already have a great deal of the primitive knowledge I might want, though it may not be implemented in the way I might want it implemented
  
  
  If I build everything myself:
  1. I need to implement unification
  2. I need to implement substitution
  3. I need to decide on the syntax I'll use
  4. I have more control
  5. I need to implement all the background kowledge I want to use
- State "DOING"      from "TODO"       [2017-04-10 Mon 09:19]
:END:
I'll build up to a full TRS iteratively as follows:
- add signatures
- add variable terms
- add application terms
- add rewrite rules

I can't do any sort of computation without first having data structures over which to compute. So, each iteration will first extend the parser and will then extend the evaluator.

** DONE handle whitespace & comments
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-06 Thu 14:04] \\
  I'm getting my feet wet and figuring out how to do this sort of work in Python, so this was a good place to start.
- State "DOING"      from "TODO"       [2017-04-06 Thu 13:30] \\
  I'll just do this first to get the basic structure set
:END:
** DONE add signatures
:LOGBOOK:
- State "DONE"       from "DOING"      [2017-04-07 Fri 11:44]
- State "DOING"      from "TODO"       [2017-04-07 Fri 09:37]
:END:
*** DONE lex the tokens for signatures: "signature" and symbols
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 09:39] \\
  This was simple to achieve, and something I did yesterday.
:END:
*** DONE perform a dumb-parse of the signature
:LOGBOOK:
- Note taken on [2017-04-07 Fri 09:52] \\
  Also, I just realized that while long-term, I'd like to be able to pick apart operators and variables syntactically, we can't do that yet because we can't represent terms. But, we can also get rid of the "signature" keyword. We can instead focus on just picking out individual symbols and adding them to the signature. This will require, however, that I figure out how to separate operators from variables syntactically. I can do that in one of two ways. I can introduce a keyword like "signature", which I would prefer not to do, as it requires the clunky idiom of declaring a symbol before using it. This may be premature optimization, though, so let's stick with the simple thing of just declaring operators explicitly.
- State "DONE"       from "TODO"       [2017-04-07 Fri 09:39] \\
  This was also simple to achieve. I'm now able to collect something that looks like the following:
  
  [('signature', ['<sym1>', '<sym2>',..., '<symN>'])]
  
  This is nice; it allows me to create the signature across multiple lines. That is, I could create something like the following:
  
  [('signature', ['<sym1>', '<sym2>',..., '<symM>']),
   ('signature', ['<symM+1>', '<symM+2>',..., '<symM+N>'])]
  
  What I ultimately want to produce, however, isn't a list of multiple signatures, but a single TRS. So, I need to find a way to insert take the knowledge, as I collect it, and transform it into a TRS. Right now, my TRS should only have the signature. So, the goal here is to produce a single signature as the result.
:END:
*** DONE improve the dumb-parse to create a Signature object
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 11:44]
:END:
** DONE add variable & constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:15]
:END:
*** DONE lex variables and constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 13:12] \\
  This was simple to do. Variables and constants are just symbols. All I needed to add were a few brackets in case cosntant terms were treated as operators applied to nothing.
:END:
*** DONE parse variables and constant terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 13:13] \\
  The entire parse has to be done in stages. That is, we can determine the rough role of each line (e.g. add to the signature, add a rewrite rule, give a term to evaluate), but we can't determine its precise role until considering the rest of the program space. That is, we have to to build up the program incrementally. ~load_source~ should probably do that work rather than the parser iself.
:END:
** DONE add application terms
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:34]
:END:
*** DONE no new lexer rules are needed
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:32] \\
  Yay!
:END:
*** DONE add parser rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:32] \\
  These were pretty straightforward, though who knows if the parser is really any good. What's going to be more interesting is step immediately following parsing, where we start building the TRS and then evaluating it.
:END:
** DONE add rewrite rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-07 Fri 14:47] \\
  This was again pretty simple. It took me a while to get rolling today, but now that I'm going, I'm making good progress.
:END:
** DONE create the TRS from the list of Operators and rules
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-12 Wed 10:53]
:END:
** DONE add substitution and evaluation
:LOGBOOK:
- State "DONE"       from "TODO"       [2017-04-12 Wed 10:53]
:END:
* TODO write a REPL?
* TODO add postfix, prefix, infix, nonfix, and outfix operators
* TODO add function application via juxtaposition (use function = head rule)
