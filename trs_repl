#!/usr/local/bin/python
"""TeRF: a Term Rewriting Framework

Usage:
    terf [--batch=<filename>] [--print=<level>] [--steps=<N>]

Options:
    --batch=<filename>  Process <filename> in batch mode.
    --print=<int>       how to print terms [default: 0].
    --steps=<int>       maximum execution steps for each term. [default: 1000]
"""

# TODO: add tracing options

from TeRF.parser import parser, load_source, add_rule, make_term
from TeRF.TRS import TRS, Op, RR, App
from TeRF.Rewrite import rewrite
from TeRF.Sampling import sample_term

import re


def batch_process(filename, verbosity, count):
    trs, terms = load_source(filename)
    print 'Rules:'
    for rule in trs.rules:
        print '\n    {}'.format(rule)
    print '\nEvaluations:'
    for term in terms:
        if verbosity >= 0:
            print '\n    {} -*-> {}'.format(term.pretty_print(2*verbosity),
                trs.eval(term, steps=count).pretty_print(2*verbosity))
        else:
            print '\n    {} -*-> {}'.format(term,
                                            trs.eval(term, steps=count))


def repl(verbosity, count):
    trs = TRS()
    while True:
        try:
            statements = [s.strip() for s in repl_read().split(';') if s != '']
            for statement in statements:
                output, new_ss = repl_eval(trs, statement, verbosity, count)
                if output != '' and output is not None:
                    print output
                statements += new_ss
        except EOFError:
            break


def repl_read():
    try:
        return raw_input('>> ') + ';'
    except NameError:
        return input('>> ') + ';'


def repl_eval(trs, statement, verbosity, count):
    quit = re.compile('quit')
    exit = re.compile('exit')
    show = re.compile('show')
    delete = re.compile('del(ete)?\s+(?P<type>(rule|op(erator)?))\s+(?P<obj>\S+)')
    save = re.compile('save\s+(?P<filename>\S+)')
    load = re.compile('load\s+(?P<filename>\S+)')
    canon = re.compile('canon(ical)?\s+(?P<term>.+)')
    pretty = re.compile('pretty\s+(?P<term>.+)')
    parens = re.compile('paren(s|thesized)?\s+(?P<term>.+)')
    generate = re.compile('generate')
    # TODO: print term as tree?
    
    if quit.match(statement) or exit.match(statement):
        raise EOFError
    if show.match(statement):
        return show_trs(trs), []
    if delete.match(statement):
        obj = delete.match(statement).group('obj')
        if delete.match(statement).group('type') == 'rule':
            trs.del_rule(int(obj))
            return None, []
        try:
            op = [op for op in trs.operators if op.name == obj][0]
            trs.del_op(op)
        except IndexError:
            pass
        return None, []
    if save.match(statement):
        save_trs(trs, save.match(statement).group('filename'))
        return None, []
    if load.match(statement):
        return None, load_file(load.match(statement).group('filename'))
    if canon.match(statement):
        return print_term(canon.match(statement).group('term'), 'canon'), []
    if pretty.match(statement):
        return print_term(pretty.match(statement).group('term'), 'pretty'), []
    if parens.match(statement):
        return print_term(parens.match(statement).group('term'), 'parens'), []
    if generate.match(statement):
        rule = make_a_named_term(trs)
        return None, [str(rule), 'show']
    else:
        trs = process_statement(trs, statement, verbosity, count)
        return None, []


def make_a_named_term(trs):
    lhs = App(Op(), [])
    rhs = sample_term(trs.operators, invent=False)
    return RR(lhs, rhs)


def show_trs(trs):
    operators = ', '.join(o.name + '/' + str(o.arity) for o in trs.operators)
    rules = '\n'.join('{:d}: {}'.format(i, rule)
                      for i, rule in enumerate(trs.rules)) 
    return operators + '\n' + rules


def save_trs(trs, filename):
    with open(filename, 'w') as f:
        f.write(';\n'.join([str(rule) for rule in trs.rules])+';\n')


def load_file(filename):
    statements = []
    with open(filename, 'r') as file:
        for line in file:
            statements += [s.strip() for s in line.strip().split(';')
                           if s != '']
        return statements


def print_term(term, how):
    s = parser.parse(term + ';')[0]
    if s[0] != 'term':
        return ''
    term = make_term(s[1])
    if how == 'canon':
        return str(term)
    if how == 'pretty':
        return term.pretty_print(verbose=0)
    if how == 'parens':
        return term.pretty_print(verbose=1)


def process_statement(trs, statement, verbosity, count):
    s = parser.parse(statement + ';')[0]
    if s[0] == 'rule':
        trs = add_rule(trs, s[1], s[2])
    elif s[0] == 'term':
        term = make_term(s[1])
        evaled = rewrite(trs, term, max_steps=count)
        if verbosity >= 0:
            print evaled.pretty_print(2*verbosity)
        else:
            print evaled
    else:
        print 'Oops! ' + str(s)
    return trs


if __name__ == "__main__":
    from docopt import docopt
    arguments = docopt(__doc__, version="terf 0.0.1")
    if arguments['--batch']:
        batch_process(arguments['--batch'],
                      int(arguments['--print']),
                      int(arguments['--steps']))
    else:
        repl(int(arguments['--print']),
             int(arguments['--steps']))

